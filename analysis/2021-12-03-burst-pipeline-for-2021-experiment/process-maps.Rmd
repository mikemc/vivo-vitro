This notebook processes the BURST output into a count matrix, where each row is
a sample and each column is a reference genome, and counts denote the number of
unambiguous insert maps to the reference.

## Setup

```{r}
library(here)
library(fs)

library(data.table)
library(dplyr, warn.conflicts = FALSE)

library(tidyverse)

library(progress)
```

The S1 samples are already named by `dna_sample_id`, but the S2 samples are
named by well and need to be converted. For this, we need the map from well id
to DNA sample id,
```{r}
well_map <- here("output/sample-data", "dna-sample-data.Rds") %>% 
  readRDS %>%
  transmute(
    dna_sample_id,
    # Get well in "A01" format
    well = str_glue('{row}{str_pad(column, 2, "left", "0")}')
  ) %>%
  glimpse
```

```{r}
ref_dir <- here("data", "references", "bacteria", "v2")
refs <- here("output", "strain-data", "reference-genome-metadata.Rds") %>%
  readRDS %>%
  mutate(local_file = file.path(ref_dir, ftp_genome_file))
```

Download the references,
```{r, eval = FALSE}
refs %>%
  transmute(
    url = file.path(ftp_path, ftp_genome_file),
    destfile = local_file
    ) %>%
  pwalk(download.file)
```

Map from sequence names to assembly accessions for the reference genomes,
```{r}
seq_map <- refs %>%
  transmute(
    sseqid = map(local_file, ~names(Biostrings::readDNAStringSet(.x))),
    target = assembly_accession
  ) %>%
  unnest(sseqid)
setDT(seq_map)
```

Burst results,
```{r}
btb <- tibble(center_id = c("s1", "s2")) %>%
  mutate(
    dir = here("analysis", "2020-10-07-burst-pipeline", "output", center_id),
    file = map(dir, dir_ls, glob = "*-burst.Rds")
  ) %>%
  select(-dir) %>%
  unnest(file)
```

## Compute the unambiguous maps for each sample

The BURST output contains all tied best maps for each read, including forward
(R1) and reverse (R2) reads for the S2 data. From the maps for a sample, the
following functions count up the number of _unambiguous insert maps_ to each
target (reference), for either single or paired-end reads.

```{r}
count_unambig_single <- function(x) {
  if (is.character(x)) 
    x <- readRDS(x)
  setDT(x)
  x <- seq_map[x, on = "sseqid"]
  setkey(x, qseqid, target)
  x <- unique(x, by = c("qseqid", "target"))
  x[, n := .N, by = qseqid]
  # return unambiguous maps
  x[n == 1][, .(unambiguous_maps = .N), by = target]
}

count_unambig_paired <- function(x) {
  if (is.character(x)) 
    x <- readRDS(x)
  setDT(x)
  x <- seq_map[x, on = "sseqid"]
  x <- unique(x, by = c("qseqid", "target"))
  x[, c("qseqid_insert", "qseqid_mate") := tstrsplit(qseqid, "_", fixed = TRUE)
    ][, qseqid_mate := str_sub(qseqid_mate, 1, 1)]
  setkey(x, qseqid_mate, qseqid_insert)
  x <- x[, .(target = list(target)), by = .(qseqid_mate, qseqid_insert)]
  x1 <- x[.("1")]
  x2 <- x[.("2")]
  x <- merge(x1, x2, by = "qseqid_insert") # only keeps inserts with both mates
  x[, target.both := map2(target.x, target.y, intersect)]
  # return unambiguous maps
  x[map_int(target.both, length) == 1
    ][, target := unlist(target.both)
    ][, .(unambiguous_maps = .N), by = target]
}
```

Test each function on one file,
```{r, eval = FALSE}
fn <- btb %>% filter(center_id == "s1") %>% slice(2) %>% pull(file)
x <- readRDS(fn)
y <- count_unambig_single(x %>% head(1e4))

fn <- btb %>% filter(str_detect(file, "A07")) %>% pull(file)
x <- readRDS(fn)
y <- count_unambig_paired(x %>% head(1e4))
```

Process S1 files,
```{r}
s1 <- btb %>%
  filter(center_id == "s1")
pb <- progress_bar$new(
  format = "[:bar] :current/:total (:percent) in :elapsed",
  total = nrow(s1), clear = FALSE, width= 60)
s1 <- s1 %>%
  mutate(
    dna_sample_id = path_file(file) %>% str_extract("^[^\\.]+"),
    counts = map(file, ~{pb$tick(); count_unambig_single(.x)})
  ) %>%
  select(-file) %>%
  unnest(counts)
saveRDS(s1, 
  here("analysis", "2020-10-07-burst-pipeline", "output", "s1-counts.Rds")
)
```

Note, `center_id` should be made upper case before prepending to
`dna_sample_id` to make the sample names.

Process S2 files,
```{r}
s2 <- btb %>%
  filter(center_id == "s2")
pb <- progress_bar$new(
  format = "[:bar] :current/:total (:percent) in :elapsed",
  total = nrow(s2), clear = FALSE, width= 60)
s2 <- s2 %>%
  mutate(
    well = path_file(file) %>% str_extract("^[^\\.]+"),
    counts = map(file, ~{pb$tick(); count_unambig_paired(.x)})
  ) %>%
  select(-file) %>%
  unnest(counts)
saveRDS(s2, 
  here("analysis", "2020-10-07-burst-pipeline", "output", "s2-counts.Rds")
)
```

```{r}
s1 <- readRDS(here("analysis", "2020-10-07-burst-pipeline", "output",
    "s1-counts.Rds"))
s2 <- readRDS(here("analysis", "2020-10-07-burst-pipeline", "output",
    "s2-counts.Rds")) %>%
  left_join(well_map, by = "well") %>%
  select(-well)
res <- bind_rows(s1, s2) %>%
  mutate(
    across(center_id, str_to_upper),
    sample_id = str_c(center_id, dna_sample_id, sep = "_")
  ) %>%
  select(sample_id, target, unambiguous_maps)
```

## Add the host read count

Get the host reads from the V1 pipeline output,
```{r}
host <- tibble(center_id = c("S1", "S2")) %>%
  mutate(
    refstats_dir = here("analysis/2020-07-09-bbmap-pipeline",
      str_to_lower(center_id), "output"),
    file = map(refstats_dir, dir_ls, glob = "*-host-refstats.tsv"),
  ) %>%
  unnest(file) %>%
  mutate(
    id = path_file(file) %>% str_extract("^[^\\-]+"),
    data = map(file, read_tsv, col_types = "cddddiiii")
    ) %>%
  select(-refstats_dir, -file) %>%
  unnest(data) %>%
  janitor::clean_names() %>%
  rename(assembly_name = number_name)
```

Confirm that the S2 read counts are even (since they were mapped as pairs),
```{r}
x <- host %>% 
  filter(center_id == "S2") %>% 
  pull(unambiguous_reads)
stopifnot(all(0 == x %% 2))
```

Munge and join with bacterial counts,
```{r}
host0 <- host %>%
  left_join(well_map, by = c(id = "well")) %>%
  transmute(center_id, id, 
    target = str_extract(assembly_name, "GC[AF]_[0-9]+.[0-9]+"),
    unambiguous_maps = case_when(
      center_id == "S1" ~ unambiguous_reads,
      center_id == "S2" ~ unambiguous_reads %/% 2L
    ),
    dna_sample_id = case_when(
      center_id == "S1" ~ id,
      center_id == "S2" ~ dna_sample_id
    ),
    sample_id = str_c(center_id, dna_sample_id, sep = "_")
  ) %>%
  select(sample_id, target, unambiguous_maps)
res0 <- bind_rows(res, host0)
```

## Create count matrix

```{r}
mat <- res %>%
  # Sort samples by center, specimen, aliquot
  separate(sample_id, c("center_id", "specimen_id", "aliquot_number"), 
    remove = FALSE, sep = "_") %>%
  mutate(across(c("specimen_id", "aliquot_number"), as.integer)) %>%
  arrange(center_id, specimen_id, aliquot_number) %>%
  # pivot into wide form, then convert to matrix
  select(sample_id, target, unambiguous_maps) %>%
  pivot_wider(names_from = target, values_from = unambiguous_maps,
    names_sort = TRUE, values_fill = 0) %>%
  column_to_rownames("sample_id") %>%
  as("matrix")
```

```{r}
saveRDS(mat, here("output/shotgun/v2", "2020-10-12-count-matrix.Rds"))
```

## Session info

I am saving the session info on 2020-10-15. This code was run on 2020-10-11 and
2020-10-12 (when I had to fix a bug in the S1 counting). The session info
indicates that R was updated from 4.0.2 to 4.0.3 on 2020-10-10, so this R
version and these package versions (except for nvimcom) should all be correct,
as they have earlier install dates.

```{r}
sessioninfo::session_info()
#> ─ Session info ─────────────────────────────────────────────────────────
#>  setting  value                       
#>  version  R version 4.0.3 (2020-10-10)
#>  os       Arch Linux                  
#>  system   x86_64, linux-gnu           
#>  ui       X11                         
#>  language (EN)                        
#>  collate  en_US.UTF-8                 
#>  ctype    en_US.UTF-8                 
#>  tz       America/New_York            
#>  date     2020-10-15                  
#> 
#> ─ Packages ─────────────────────────────────────────────────────────────
#>  package      * version date       lib source        
#>  assertthat     0.2.1   2019-03-21 [1] CRAN (R 4.0.0)
#>  backports      1.1.10  2020-09-15 [1] CRAN (R 4.0.2)
#>  BiocGenerics   0.34.0  2020-04-27 [1] Bioconductor  
#>  Biostrings     2.56.0  2020-04-27 [1] Bioconductor  
#>  blob           1.2.1   2020-01-20 [1] CRAN (R 4.0.0)
#>  broom          0.7.1   2020-10-02 [1] CRAN (R 4.0.2)
#>  cellranger     1.1.0   2016-07-27 [1] CRAN (R 4.0.0)
#>  cli            2.0.2   2020-02-28 [1] CRAN (R 4.0.2)
#>  colorspace     1.4-1   2019-03-18 [1] CRAN (R 4.0.0)
#>  crayon         1.3.4   2017-09-16 [1] CRAN (R 4.0.0)
#>  data.table   * 1.13.0  2020-07-24 [1] CRAN (R 4.0.2)
#>  DBI            1.1.0   2019-12-15 [1] CRAN (R 4.0.0)
#>  dbplyr         1.4.4   2020-05-27 [1] CRAN (R 4.0.0)
#>  dplyr        * 1.0.2   2020-08-18 [1] CRAN (R 4.0.2)
#>  ellipsis       0.3.1   2020-05-15 [1] CRAN (R 4.0.0)
#>  fansi          0.4.1   2020-01-08 [1] CRAN (R 4.0.0)
#>  forcats      * 0.5.0   2020-03-01 [1] CRAN (R 4.0.0)
#>  fs           * 1.5.0   2020-07-31 [1] CRAN (R 4.0.2)
#>  generics       0.0.2   2018-11-29 [1] CRAN (R 4.0.0)
#>  ggplot2      * 3.3.2   2020-06-19 [1] CRAN (R 4.0.1)
#>  glue           1.4.2   2020-08-27 [1] CRAN (R 4.0.2)
#>  gtable         0.3.0   2019-03-25 [1] CRAN (R 4.0.0)
#>  haven          2.3.1   2020-06-01 [1] CRAN (R 4.0.1)
#>  here         * 0.1     2017-05-28 [1] CRAN (R 4.0.0)
#>  hms            0.5.3   2020-01-08 [1] CRAN (R 4.0.0)
#>  httr           1.4.2   2020-07-20 [1] CRAN (R 4.0.2)
#>  IRanges        2.22.2  2020-05-21 [1] Bioconductor  
#>  janitor        2.0.1   2020-04-12 [1] CRAN (R 4.0.0)
#>  jsonlite       1.7.1   2020-09-07 [1] CRAN (R 4.0.2)
#>  lifecycle      0.2.0   2020-03-06 [1] CRAN (R 4.0.0)
#>  lubridate      1.7.9   2020-06-08 [1] CRAN (R 4.0.1)
#>  magrittr       1.5     2014-11-22 [1] CRAN (R 4.0.0)
#>  modelr         0.1.8   2020-05-19 [1] CRAN (R 4.0.0)
#>  munsell        0.5.0   2018-06-12 [1] CRAN (R 4.0.0)
#>  nvimcom      * 0.9-102 2020-10-12 [1] local         
#>  pillar         1.4.6   2020-07-10 [1] CRAN (R 4.0.2)
#>  pkgconfig      2.0.3   2019-09-22 [1] CRAN (R 4.0.0)
#>  prettyunits    1.1.1   2020-01-24 [1] CRAN (R 4.0.0)
#>  progress     * 1.2.2   2019-05-16 [1] CRAN (R 4.0.2)
#>  purrr        * 0.3.4   2020-04-17 [1] CRAN (R 4.0.0)
#>  R6             2.4.1   2019-11-12 [1] CRAN (R 4.0.0)
#>  Rcpp           1.0.5   2020-07-06 [1] CRAN (R 4.0.2)
#>  readr        * 1.3.1   2018-12-21 [1] CRAN (R 4.0.0)
#>  readxl         1.3.1   2019-03-13 [1] CRAN (R 4.0.0)
#>  reprex         0.3.0   2019-05-16 [1] CRAN (R 4.0.1)
#>  rlang          0.4.7   2020-07-09 [1] CRAN (R 4.0.2)
#>  rprojroot      1.3-2   2018-01-03 [1] CRAN (R 4.0.0)
#>  rstudioapi     0.11    2020-02-07 [1] CRAN (R 4.0.0)
#>  rvest          0.3.6   2020-07-25 [1] CRAN (R 4.0.2)
#>  S4Vectors      0.26.1  2020-05-16 [1] Bioconductor  
#>  scales         1.1.1   2020-05-11 [1] CRAN (R 4.0.0)
#>  sessioninfo    1.1.1   2018-11-05 [1] CRAN (R 4.0.0)
#>  snakecase      0.11.0  2019-05-25 [1] CRAN (R 4.0.0)
#>  stringi        1.5.3   2020-09-09 [1] CRAN (R 4.0.2)
#>  stringr      * 1.4.0   2019-02-10 [1] CRAN (R 4.0.0)
#>  tibble       * 3.0.3   2020-07-10 [1] CRAN (R 4.0.2)
#>  tidyr        * 1.1.2   2020-08-27 [1] CRAN (R 4.0.2)
#>  tidyselect     1.1.0   2020-05-11 [1] CRAN (R 4.0.0)
#>  tidyverse    * 1.3.0   2019-11-21 [1] CRAN (R 4.0.0)
#>  vctrs          0.3.4   2020-08-29 [1] CRAN (R 4.0.2)
#>  withr          2.3.0   2020-09-22 [1] CRAN (R 4.0.2)
#>  xml2           1.3.2   2020-04-23 [1] CRAN (R 4.0.0)
#>  XVector        0.28.0  2020-04-27 [1] Bioconductor  
#>  zlibbioc       1.34.0  2020-04-27 [1] Bioconductor  
#> 
#> [1] /home/michael/R/x86_64-pc-linux-gnu-library/4.0
#> [2] /usr/lib/R/library
```

