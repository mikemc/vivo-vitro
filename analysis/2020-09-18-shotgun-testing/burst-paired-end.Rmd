---
title: Test a method for processing BURST paired-end results
author: Michael McLaren
date: "`r Sys.Date()`"
description:
output:
  html_document:
    toc: true
    toc_float: true
    dev: "svg"
---


```{r setup, include=FALSE}
knitr::opts_knit$set(progress = TRUE, verbose = TRUE)
# Global chunk options
knitr::opts_chunk$set(
  cache = TRUE, autodep = TRUE,
  include = TRUE, echo = TRUE,
  warning = TRUE, message = FALSE, 
  collapse = TRUE,
  fig.width = 7, fig.height = 7
)
```

## Setup

```{r}
library(here)
library(tidyverse)
library(fs)
```

```{r}
this_dir <- getwd()
burst_path <- path(this_dir, "output", "burst")
out_dirs <- file.path(burst_path, str_c("simulation-", 1:3))
```

Let's work with just reads from E. coli HS, since the HS to Nissle mismap rate
was the highest observed in the BBSplit results.

```{r}
fn <- path(out_dirs[[3]], "GCF_000017765.1-burst.Rds") # HS
# "GCF_003546975.1-burst.Rds") # Nissle
res <- fn %>% readRDS()
acc <- fn %>% path_file %>% str_extract("[^-]+")
```

Reduce to one row per read + genome (drop ties w/in same genome) and split the
qseqids into inserts and mates,
```{r}
res1 <- res %>%
  select(qseqid, target = sseqid_assembly_accession) %>%
  distinct %>%
  separate(qseqid, into = str_c("qseqid_", c("insert", "mate")),
    sep = "_(?=[12]:$)") %>%
  mutate(across(qseqid_mate, str_replace, ":", ""))
```

### Test on simple fake data

```{r}
fake <- tibble(
  qseqid_insert = str_c("i", c(1,1,1,1, 2,2,2, 3,3, 4,4, 5,5, 6)),
  qseqid_mate =              c(1,1,2,2, 1,1,2, 1,2, 1,2, 2,2, 1),
  target =        str_c("t", c(1,2,1,2, 1,2,1, 1,1, 1,2, 1,2, 1))
) %>% print
```
Here, we have various possibilities that we want to be handled properly: 

- i1 is ambiguous
- i2 is ambiguous on mate1 but unambiguous with both mates
- i3 is unambiguous on both mates and the mates agree
- i4 is unambig on each mate but they disagree
- i5 only has mate 2 and it is ambig
- i6 only has mate 1 and it is unambig

Strategy:

1. Take the intersection of targets mapped by mates for each insert; drop
   cases where only one mate mapped, or the intersection is empty.
2. compute the size of the intersection (`n_best`), and use to tally maps to
   each target and whether they are ambiguous or unambiguous, just like with
   the single-end reads.

```{r}
res2.fake <- fake %>%
  group_by(qseqid_insert, qseqid_mate) %>%
  summarize(across(target, list), .groups = "drop_last") %>%
  summarize(
    across(target, reduce, intersect), 
    paired = identical(n(), 2L),
    .groups = "keep"
  ) %>%
  print %>%
  filter(paired) %>%
  mutate(n_best = n()) %>%
  print %>%
  group_by(target) %>%
  summarize(
    unambiguous_maps = sum(n_best == 1),
    ambiguous_maps = sum(n_best > 1),
    .groups = "drop"
  ) %>%
  print
```

### Run on real data

In future, might try to speed this up by using `str_sub` to pluck off the last
3 characters.

```{r}
res2 <- res1 %>%
  group_by(qseqid_insert, qseqid_mate) %>%
  summarize(across(target, list), .groups = "drop_last") %>%
  summarize(
    across(target, reduce, intersect), 
    paired = identical(n(), 2L),
    .groups = "keep"
  ) %>%
  filter(paired) %>%
  mutate(n_best = n()) %>%
  group_by(target) %>%
  summarize(
    unambiguous_maps = sum(n_best == 1),
    ambiguous_maps = sum(n_best > 1),
    .groups = "drop"
  )
res2 %>% print
```

Rate of mismaps is
```{r}
res2 %>%
  group_by(target == acc) %>%
  summarize(across(unambiguous_maps, sum)) %>%
  mutate(across(unambiguous_maps, ~. / sum(.)))
```

Let's compare this rate of mismaps to the rate if we just used R1.
```{r}
res3 <- res1 %>%
  filter(qseqid_mate == 1) %>%
  group_by(qseqid_insert) %>%
  mutate(n_best = n()) %>%
  group_by(target) %>%
  summarize(
    unambiguous_maps = sum(n_best == 1),
    ambiguous_maps = sum(n_best > 1),
    .groups = "drop"
  )
```

```{r}
res2 %>% print
res3 %>% print
```

By using both pairs, we disambiguate around half fraction of the ambiguous R1
reads, and also reduce the mismapping rate by about half.


